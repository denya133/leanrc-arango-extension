// Generated by CoffeeScript 2.5.1
(function() {
  // This file is part of leanrc-arango-extension.

  // leanrc-arango-extension is free software: you can redistribute it and/or modify
  // it under the terms of the GNU Lesser General Public License as published by
  // the Free Software Foundation, either version 3 of the License, or
  // (at your option) any later version.

  // leanrc-arango-extension is distributed in the hope that it will be useful,
  // but WITHOUT ANY WARRANTY; without even the implied warranty of
  // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  // GNU Lesser General Public License for more details.

  // You should have received a copy of the GNU Lesser General Public License
  // along with leanrc-arango-extension.  If not, see <https://www.gnu.org/licenses/>.
  var db;

  ({db} = require('@arangodb'));

  /*
  ```coffee
  module.exports = (Module)->
    class CreateUsersCollectionMigration extends Module::Migration
      @inheritProtected()
      @include Module::ArangoMigrationMixin # в этом миксине должны быть реализованы платформозависимые методы, которые будут посылать нативные запросы к реальной базе данных

      @module Module

      @up ->
        yield @createCollection 'users'
        yield @addField 'users', name, 'string'
        yield @addField 'users', description, 'text'
        yield @addField 'users', createdAt, 'date'
        yield @addField 'users', updatedAt, 'date'
        yield @addField 'users', deletedAt, 'date'
        yield return

      @down ->
        yield @dropCollection 'users'
        yield return

    return CreateUsersCollectionMigration.initialize()
  ```

  Это эквивалентно

  ```coffee
  module.exports = (Module)->
    class CreateUsersCollectionMigration extends Module::Migration
      @inheritProtected()
      @include Module::ArangoMigrationMixin # в этом миксине должны быть реализованы платформозависимые методы, которые будут посылать нативные запросы к реальной базе данных

      @module Module

      @change ->
        @createCollection 'users'
        @addField 'users', name, 'string'
        @addField 'users', description, 'text'
        @addField 'users', createdAt, 'date'
        @addField 'users', updatedAt, 'date'
        @addField 'users', deletedAt, 'date'

    return CreateUsersCollectionMigration.initialize()
  ```
  */
  // Миксин объявляет реализации для виртуальных методов основного Migration класса
  // миксин должен содержать нативный платформозависимый код для обращения к релаьной базе данных на понятном ей языке.
  module.exports = function(Module) {
    var AnyT, DEBUG, EnumG, FuncG, InterfaceG, LEVELS, ListG, MaybeG, Migration, Mixin, SEND_TO_LOG, StructG, UnionG, _, assign, co, inflect, jsonStringify;
    ({
      AnyT,
      FuncG,
      ListG,
      EnumG,
      MaybeG,
      UnionG,
      InterfaceG,
      StructG,
      Migration,
      Mixin,
      LogMessage: {SEND_TO_LOG, LEVELS, DEBUG},
      Utils: {_, inflect, assign, co, jsonStringify}
    } = Module.prototype);
    return Module.defineMixin(Mixin('ArangoMigrationMixin', function(BaseClass = Migration) {
      return (function() {
        var DOWN, SUPPORTED_TYPES, UP, _Class;

        _Class = class extends BaseClass {};

        _Class.inheritProtected();

        ({UP, DOWN, SUPPORTED_TYPES} = _Class.prototype);

        _Class.public(_Class.async({
          createCollection: FuncG([String, MaybeG(Object)])
        }, {
          default: function*(name, options = {}) {
            var qualifiedName;
            qualifiedName = this.collection.collectionFullName(name);
            if (!db._collection(qualifiedName)) {
              this.collection.sendNotification(SEND_TO_LOG, `ArangoMigrationMixin::createCollection qualifiedName = ${qualifiedName}, options = ${jsonStringify(options)}`, LEVELS[DEBUG]);
              db._createDocumentCollection(qualifiedName, options);
            }
          }
        }));

        _Class.public(_Class.async({
          createEdgeCollection: FuncG([String, String, MaybeG(Object)])
        }, {
          default: function*(collection_1, collection_2, options = {}) {
            var qualifiedName;
            qualifiedName = this.collection.collectionFullName(`${collection_1}_${collection_2}`);
            if (!db._collection(qualifiedName)) {
              this.collection.sendNotification(SEND_TO_LOG, `ArangoMigrationMixin::createEdgeCollection qualifiedName = ${qualifiedName}, options = ${jsonStringify(options)}`, LEVELS[DEBUG]);
              db._createEdgeCollection(qualifiedName, options);
            }
          }
        }));

        _Class.public(_Class.async({
          addField: FuncG([
            String,
            String,
            UnionG(EnumG(SUPPORTED_TYPES),
            InterfaceG({
              type: EnumG(SUPPORTED_TYPES),
              default: AnyT
            }))
          ])
        }, {
          default: function*(collection_name, field_name, options) {
            var initial, qualifiedName, vsQuery;
            qualifiedName = this.collection.collectionFullName(collection_name);
            if (_.isString(options)) {
              return;
            }
            if (options.default != null) {
              if (_.isNumber(options.default) || _.isBoolean(options.default)) {
                initial = options.default;
              } else if (_.isDate(options.default)) {
                initial = options.default.toISOString();
              } else if (_.isString(options.default)) {
                initial = `'${options.default}'`;
              } else if (_.isPlainObject(options.default)) {
                initial = JSON.stringify(options.default);
              } else if (_.isArray(options.default)) {
                initial = JSON.stringify(options.default);
              } else {
                initial = null;
              }
            } else {
              initial = null;
            }
            if (initial != null) {
              vsQuery = `FOR doc IN ${qualifiedName} UPDATE doc._key WITH {${field_name}: ${initial}} IN ${qualifiedName}`;
              this.collection.sendNotification(SEND_TO_LOG, `ArangoMigrationMixin::addField vsQuery ${vsQuery}`, LEVELS[DEBUG]);
              db._query(vsQuery);
            }
          }
        }));

        _Class.public(_Class.async({
          addIndex: FuncG([
            String,
            ListG(String),
            InterfaceG({
              type: EnumG('hash',
            'skiplist',
            'persistent',
            'geo',
            'fulltext'),
              unique: MaybeG(Boolean),
              sparse: MaybeG(Boolean)
            })
          ])
        }, {
          default: function*(collection_name, field_names, options) {
            var opts, qualifiedName, ref, ref1, ref2;
            // TODO; fulltext индекс вызывает ошибку в аранге - надо дебажить
            qualifiedName = this.collection.collectionFullName(collection_name);
            opts = {
              type: (ref = options.type) != null ? ref : 'hash',
              fields: field_names != null ? field_names : []
            };
            if (opts.type === 'fulltext') {
              opts.minLength = 3;
            } else {
              opts.unique = (ref1 = options.unique) != null ? ref1 : false;
              opts.sparse = (ref2 = options.sparse) != null ? ref2 : false;
            }
            this.collection.sendNotification(SEND_TO_LOG, `ArangoMigrationMixin::addIndex opts ${jsonStringify(opts)}`, LEVELS[DEBUG]);
            db._collection(qualifiedName).ensureIndex(opts);
          }
        }));

        _Class.public(_Class.async({
          addTimestamps: FuncG([String, MaybeG(Object)])
        }, {
          default: function*(collection_name, options = {}) {}
        }));

        // NOTE: нет смысла выполнять запрос, т.к. в addField есть проверка if initial? и если null, то атрибут не добавляется
        _Class.public(_Class.async({
          changeCollection: FuncG([String, Object])
        }, {
          default: function*(name, options) {
            var qualifiedName;
            qualifiedName = this.collection.collectionFullName(name);
            this.collection.sendNotification(SEND_TO_LOG, `ArangoMigrationMixin::changeCollection qualifiedName = ${qualifiedName}, options = ${jsonStringify(options)}`, LEVELS[DEBUG]);
            db._collection(qualifiedName).properties(options);
          }
        }));

        _Class.public(_Class.async({
          changeField: FuncG([
            String,
            String,
            UnionG(EnumG(SUPPORTED_TYPES),
            InterfaceG({
              type: EnumG(SUPPORTED_TYPES)
            }))
          ])
        }, {
          default: function*(collection_name, field_name, options) {
            var array, binary, boolean, date, datetime, decimal, float, hash, integer, json, number, primary_key, qualifiedName, string, text, time, timestamp, type, typeCast, vsQuery;
            ({json, binary, boolean, date, datetime, number, decimal, float, integer, primary_key, string, text, time, timestamp, array, hash} = SUPPORTED_TYPES);
            type = _.isString(options) ? options : options.type;
            typeCast = (function() {
              switch (type) {
                case boolean:
                  return `TO_BOOL(doc.${field_name})`;
                case decimal:
                case float:
                case integer:
                case number:
                  return `TO_NUMBER(doc.${field_name})`;
                case string:
                case text:
                case primary_key:
                case binary:
                  return `TO_STRING(JSON_STRINGIFY(doc.${field_name}))`;
                case array:
                  return `TO_ARRAY(doc.${field_name})`;
                case json:
                case hash:
                  return `JSON_PARSE(TO_STRING(doc.${field_name}))`;
                case date:
                case datetime:
                  return `DATE_ISO8601(doc.${field_name})`;
                case time:
                case timestamp:
                  return `DATE_TIMESTAMP(doc.${field_name})`;
              }
            })();
            qualifiedName = this.collection.collectionFullName(collection_name);
            vsQuery = `FOR doc IN ${qualifiedName} UPDATE doc._key WITH {${field_name}: ${typeCast}} IN ${qualifiedName}`;
            this.collection.sendNotification(SEND_TO_LOG, `ArangoMigrationMixin::changeField vsQuery ${vsQuery}`, LEVELS[DEBUG]);
            db._query(vsQuery);
          }
        }));

        _Class.public(_Class.async({
          renameField: FuncG([String, String, String])
        }, {
          default: function*(collection_name, field_name, new_field_name) {
            var qualifiedName, vsQuery;
            qualifiedName = this.collection.collectionFullName(collection_name);
            vsQuery = `FOR doc IN ${qualifiedName} LET doc_with_n_field = MERGE(doc, {${new_field_name}: doc.${field_name}}) LET doc_without_o_field = UNSET(doc_with_n_field, '${field_name}') REPLACE doc._key WITH doc_without_o_field IN ${qualifiedName}`;
            this.collection.sendNotification(SEND_TO_LOG, `ArangoMigrationMixin::renameField vsQuery ${vsQuery}`, LEVELS[DEBUG]);
            db._query(vsQuery);
          }
        }));

        _Class.public(_Class.async({
          renameIndex: FuncG([String, String, String])
        }, {
          default: function*(collection_name, old_name, new_name) {}
        }));

        // not supported in ArangoDB because index has not name
        _Class.public(_Class.async({
          renameCollection: FuncG([String, String])
        }, {
          default: function*(collectionName, newCollectionName) {
            var newQualifiedName, qualifiedName;
            qualifiedName = this.collection.collectionFullName(collectionName);
            newQualifiedName = this.collection.collectionFullName(newCollectionName);
            this.collection.sendNotification(SEND_TO_LOG, `ArangoMigrationMixin::renameCollection qualifiedName, newQualifiedName = ${qualifiedName}, ${newQualifiedName}`, LEVELS[DEBUG]);
            db._collection(qualifiedName).rename(newQualifiedName);
          }
        }));

        _Class.public(_Class.async({
          dropCollection: FuncG(String)
        }, {
          default: function*(name) {
            var qualifiedName;
            qualifiedName = this.collection.collectionFullName(name);
            if (db._collection(qualifiedName) != null) {
              this.collection.sendNotification(SEND_TO_LOG, `ArangoMigrationMixin::dropCollection qualifiedName = ${qualifiedName}`, LEVELS[DEBUG]);
              db._drop(qualifiedName);
            }
          }
        }));

        _Class.public(_Class.async({
          dropEdgeCollection: FuncG([String, String])
        }, {
          default: function*(collection_1, collection_2) {
            var qualifiedName;
            qualifiedName = this.collection.collectionFullName(`${collection_1}_${collection_2}`);
            if (db._collection(qualifiedName) != null) {
              this.collection.sendNotification(SEND_TO_LOG, `ArangoMigrationMixin::dropEdgeCollection qualifiedName = ${qualifiedName}`, LEVELS[DEBUG]);
              db._drop(qualifiedName);
            }
          }
        }));

        _Class.public(_Class.async({
          removeField: FuncG([String, String])
        }, {
          default: function*(collection_name, field_name) {
            var qualifiedName, vsQuery;
            qualifiedName = this.collection.collectionFullName(collection_name);
            vsQuery = `FOR doc IN ${qualifiedName} LET doc_without_f = UNSET(doc, '${field_name}') REPLACE doc._key WITH doc_without_f IN ${qualifiedName}`;
            this.collection.sendNotification(SEND_TO_LOG, `ArangoMigrationMixin::removeField vsQuery ${vsQuery}`, LEVELS[DEBUG]);
            db._query(vsQuery);
          }
        }));

        _Class.public(_Class.async({
          removeIndex: FuncG([
            String,
            ListG(String),
            InterfaceG({
              type: EnumG('hash',
            'skiplist',
            'persistent',
            'geo',
            'fulltext'),
              unique: MaybeG(Boolean),
              sparse: MaybeG(Boolean)
            })
          ])
        }, {
          default: function*(collection_name, field_names, options) {
            var index, opts, qualifiedName, ref, ref1, ref2;
            qualifiedName = this.collection.collectionFullName(collection_name);
            opts = {
              type: (ref = options.type) != null ? ref : 'hash',
              fields: field_names != null ? field_names : []
            };
            if (opts.type === 'fulltext') {
              opts.minLength = 3;
            } else {
              opts.unique = (ref1 = options.unique) != null ? ref1 : false;
              opts.sparse = (ref2 = options.sparse) != null ? ref2 : false;
            }
            this.collection.sendNotification(SEND_TO_LOG, `ArangoMigrationMixin::removeIndex opts ${jsonStringify(opts)}`, LEVELS[DEBUG]);
            index = null;
            db._collection(qualifiedName).getIndexes().forEach(function(item) {
              if (_.isEqual(item.fields, opts.fields) && item.type === opts.type && item.unique === opts.unique && item.sparse === opts.sparse) {
                return index = item;
              }
            });
            if (index != null) {
              this.collection.sendNotification(SEND_TO_LOG, `ArangoMigrationMixin::removeIndex index ${jsonStringify(index)}`, LEVELS[DEBUG]);
              db._collection(qualifiedName).dropIndex(index);
            }
          }
        }));

        _Class.public(_Class.async({
          removeTimestamps: FuncG([String, MaybeG(Object)])
        }, {
          default: function*(collection_name, options = {}) {
            var qualifiedName, vsQuery;
            qualifiedName = this.collection.collectionFullName(collection_name);
            vsQuery = `FOR doc IN ${qualifiedName} LET new_doc = UNSET(doc, 'createdAt', 'updatedAt', 'deletedAt') REPLACE doc._key WITH new_doc IN ${qualifiedName}`;
            this.collection.sendNotification(SEND_TO_LOG, `ArangoMigrationMixin::removeTimestamps vsQuery ${vsQuery}`, LEVELS[DEBUG]);
            db._query(vsQuery);
          }
        }));

        _Class.public({
          customLocks: FuncG([], Object)
        }, {
          default: function() {
            return {};
          }
        });

        _Class.public({
          getLocks: FuncG([], StructG({
            read: ListG(String),
            write: ListG(String)
          }))
        }, {
          default: function() {
            var read, vlCollectionNames, vrCollectionPrefix, write;
            vrCollectionPrefix = new RegExp(`^${inflect.underscore(this.Module.name)}_`);
            vlCollectionNames = db._collections().reduce(function(alResults, aoCollection) {
              var name;
              if (vrCollectionPrefix.test(name = aoCollection.name())) {
                if (!/migrations$/.test(name)) {
                  alResults.push(name);
                }
              }
              return alResults;
            }, []);
            write = vlCollectionNames;
            read = vlCollectionNames.concat([`${inflect.underscore(this.Module.name)}_migrations`, '_queues', '_jobs']);
            return {read, write};
          }
        });

        _Class.public(_Class.async({
          up: Function
        }, {
          default: function*() {
            var args, i, iplSteps, len, method, nonTransactionableSteps, read, ref, ref1, self, steps, transactionableSteps, write;
            iplSteps = this.constructor.instanceVariables['_steps'].pointer;
            ({read, write} = assign({}, this.getLocks(), this.customLocks()));
            steps = (ref = (ref1 = this[iplSteps]) != null ? ref1.slice(0) : void 0) != null ? ref : [];
            [nonTransactionableSteps, transactionableSteps] = steps.reduce(function(prev, current) {
              var nonTrans, ref2, trans;
              [nonTrans, trans] = prev;
              if ((ref2 = current.method) === 'createCollection' || ref2 === 'createEdgeCollection' || ref2 === 'addIndex' || ref2 === 'removeIndex' || ref2 === 'changeCollection' || ref2 === 'renameIndex' || ref2 === 'renameCollection' || ref2 === 'dropCollection' || ref2 === 'dropEdgeCollection') {
                nonTrans.push(current);
              } else {
                trans.push(current);
              }
              return [nonTrans, trans];
            }, [[], []]);
            self = this;
            if (nonTransactionableSteps.length > 0) {
              for (i = 0, len = nonTransactionableSteps.length; i < len; i++) {
                ({method, args} = nonTransactionableSteps[i]);
                yield self[method](...args);
              }
            }
            // yield forEach nonTransactionableSteps, ({method,args})->
            //   yield @[method] args...
            // , @
            if (transactionableSteps.length > 0) {
              yield db._executeTransaction({
                waitForSync: true,
                intermediateCommitSize: 33554432,
                collections: {
                  read: read,
                  write: write,
                  allowImplicit: false
                },
                action: co.wrap(function*(params) {
                  var j, lambda, len1, ref2;
                  ref2 = params.steps;
                  for (j = 0, len1 = ref2.length; j < len1; j++) {
                    ({method, args} = ref2[j]);
                    if (method === 'reversible') {
                      [lambda] = args;
                      yield lambda.call(self, {
                        up: function(f) {
                          return f();
                        },
                        down: function() {
                          return Module.prototype.Promise.resolve();
                        }
                      });
                    } else {
                      yield self[method](...args);
                    }
                  }
                }),
                params: {
                  steps: transactionableSteps
                }
              });
            }
          }
        }));

        // action: @wrap (params)->
        //   forEach params.steps, ({ method, args }) ->
        //     if method is 'reversible'
        //       [lambda] = args
        //       yield lambda.call @,
        //         up: (f)-> f()
        //         down: -> Module::Promise.resolve()
        //     else
        //       yield @[method] args...
        //   , params.self
        // params: {self: @, steps: transactionableSteps}
        _Class.public(_Class.async({
          down: Function
        }, {
          default: function*() {
            var args, collectionName, i, iplSteps, len, method, newName, nonTransactionableSteps, oldName, read, ref, ref1, self, steps, transactionableSteps, write;
            iplSteps = this.constructor.instanceVariables['_steps'].pointer;
            ({read, write} = assign({}, this.getLocks(), this.customLocks()));
            steps = (ref = (ref1 = this[iplSteps]) != null ? ref1.slice(0) : void 0) != null ? ref : [];
            steps.reverse();
            [transactionableSteps, nonTransactionableSteps] = steps.reduce(function(prev, current) {
              var nonTrans, ref2, trans;
              [trans, nonTrans] = prev;
              if ((ref2 = current.method) === 'createCollection' || ref2 === 'createEdgeCollection' || ref2 === 'addIndex' || ref2 === 'removeIndex' || ref2 === 'changeCollection' || ref2 === 'renameIndex' || ref2 === 'renameCollection' || ref2 === 'dropCollection' || ref2 === 'dropEdgeCollection') {
                nonTrans.push(current);
              } else {
                trans.push(current);
              }
              return [trans, nonTrans];
            }, [[], []]);
            self = this;
            if (transactionableSteps.length > 0) {
              yield db._executeTransaction({
                waitForSync: true,
                intermediateCommitSize: 33554432,
                collections: {
                  read: read,
                  write: write,
                  allowImplicit: false
                },
                action: co.wrap(function*(params) {
                  var args, collectionName, i, lambda, len, method, newName, oldName, ref2;
                  ref2 = params.steps;
                  for (i = 0, len = ref2.length; i < len; i++) {
                    ({method, args} = ref2[i]);
                    if (method === 'reversible') {
                      [lambda] = args;
                      yield lambda.call(self, {
                        up: function() {
                          return Module.prototype.Promise.resolve();
                        },
                        down: function(f) {
                          return f();
                        }
                      });
                    } else if (method === 'renameField') {
                      [collectionName, oldName, newName] = args;
                      yield self[method](collectionName, newName, oldName);
                    } else {
                      yield self[Migration.prototype.REVERSE_MAP[method]](...args);
                    }
                  }
                }),
                params: {
                  steps: transactionableSteps
                }
              });
            }
            // action: @wrap (params)->
            //   forEach params.steps, ({ method, args }) ->
            //     if method is 'reversible'
            //       [lambda] = args
            //       yield lambda.call @,
            //         up: -> Module::Promise.resolve()
            //         down: (f)-> f()
            //     else if method is 'renameField'
            //       [collectionName, oldName, newName] = args
            //       yield @[method] collectionName, newName, oldName
            //     else
            //       yield @[Migration::REVERSE_MAP[method]] args...
            //   , params.self
            // params: {self: @, steps: transactionableSteps}
            if (nonTransactionableSteps.length > 0) {
              for (i = 0, len = nonTransactionableSteps.length; i < len; i++) {
                ({method, args} = nonTransactionableSteps[i]);
                if (method === 'renameIndex') {
                  [collectionName, oldName, newName] = args;
                  yield this[method](collectionName, newName, oldName);
                } else if (method === 'renameCollection') {
                  [collectionName, newName] = args;
                  yield this[method](newName, collectionName);
                } else {
                  yield this[Migration.prototype.REVERSE_MAP[method]](...args);
                }
              }
            }
          }
        }));

        // yield forEach nonTransactionableSteps, ({method,args})->
        //   if method is 'renameIndex'
        //     [collectionName, oldName, newName] = args
        //     yield @[method] collectionName, newName, oldName
        //   else if method is 'renameCollection'
        //     [collectionName, newName] = args
        //     yield @[method] newName, collectionName
        //   else
        //     yield @[Migration::REVERSE_MAP[method]] args...
        // , @
        _Class.initializeMixin();

        return _Class;

      }).call(this);
    }));
  };

}).call(this);
